单例模式：保证一个类有一个实例，并提供一个访问它的全局访问点。实现分懒汉式、饿汉式两种。

懒汉式：既然懒，那么在创建对象实例的时候就不着急，会一直等到马上要使用对象实例的时候才会创建。因此在装载对象实例的时候不创建实例。
饿汉式：既然饿，那么在创建对象实例的时候就比较着急，于是就在装载类的时候就创建对象实例。

对于单例模式而言，不管采用何种实现方式，它都只关心类实例的创建问题，并不关心具体的业务功能。

单例模式的懒汉式实现体现了延迟加载的思想。
延迟加载：一开始不要加载资源或者数据，一直等，等到马上就要使用这个资源或者数据了，躲不过去了才去加载。这在实际开发中式一种很常见的思想，尽可
能地节约资源。

单例模式的懒汉式实现还体现了缓存的思想。
缓存，当某些资源或者数据被频繁地使用，而这些资源或数据存储在系统外部，比如数据库，硬盘文件等，每次操作这些数据的时候都得从外部获取，速度会很
慢，造成性能问题。
一个简单的解决方法是把这些数据缓存到内存中，每次操作的时候，先到内存里面查，看有没有数据，如果有，就直接使用，如果没有就获取它，并设置到缓存
中。缓存是一种典型的空间换时间的方案。

单例模式的优缺点：
时间和空间
线程安全：不加同步的懒汉式是线程不安全的。
懒汉式实现线程安全引入 synchronized 会降低整个访问的速度，而且每次都要判断。

使用"双重检查加锁"的方式既实现线程安全，又能使性能不收很大影响。
双重检查加锁：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法过后，先检查实例是否存在，如果不存在就才进入下面的同步块，这是
第一重检查。进入同步块后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次，从而减
少了多次在同步情况下进行判断所浪费的时间。
Java 关键字 volatile: 被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处
理该变量。
由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。

既能实现延迟加载，又能实现线程安全的实现方式？
Lazy initialization holder class模式，综合使用Java的类级内部类和多线程缺省同步锁。

在多线程开发中，为了解决并发问题，主要通过使用synchronized来加互斥锁进行同步控制。但是在某些情况下，JVM已经隐含地执行了同步：
由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时
访问final字段
在创建线程之前创建对象时
线程可以看见它将要处理的对象时

单例的本质：控制实例数目。

何时选用？
当需要控制一个类的实例只能有一个，而且客户只能从一个全局访问点访问它时，可以选用单例模式。


