外观模式：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，使得这一子系统更容易使用。

外观模式就是通过引入一个外观类，在这个类里面定义客户端想要的简单方法，在这些方法里，由外观类去分别调用内部的多个模块来实现，从而让客户端变得
简单。这样一来，客户端就只需要和外观类交互就可以了。

外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部更简单的使用子系统。

使用外观模式和不使用外观模式的区别？
表面上看是把客户端代码搬到Facade里面了，实际上Facade是与子系统在一起的，它相当于屏蔽了外部客户端和系统内部模块的交互，从而将各模块整合成一
个整体对外。同时可以被多个客户端调用，实现复用。

外观模式的实现
对于一个子系统来说，外观类不需要很多，通常可以实现成为一个单例。
可以将外观模式实现成为interface，只是这样会增加系统的复杂程度。

外观模式的优点：
松散耦合
简单易用
更好地划分访问的层次
缺点：
过多的或者不太合理的Facade容易让人迷惑，到底是调用Facade好还是直接调用模块好。

外观模式的本质：封装交互，简化调用 （组合调用）
外观模式很好地体现了"最少只是原则"。

外观模式的选用？
如果希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式。
如果想让客户程序和抽象类的实现部分松散耦合，可以使用。
如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系。